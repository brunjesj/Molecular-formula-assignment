###############################################################################
#This provides a graphical user interface to perform all calculations. 
#Results from each step are being exported into the local R environment.
#
# Work in progress. No diagnostic plots and less options compared to running the functions individually
###############################################################################
library(bit64)
library(shiny)
library(data.table)
library(quantreg)
library(magrittr)
library(DT)
library(plotly)
library(mgcv)
library(igraph)

#functions

calculate_noise <- function(blank, approach=1, confidence_level = 0.998, MDL_level = 2.5){
  colnames(blank)[1] <- "m.z"
  colnames(blank)[2] <- "I"
  blank[, I := as.numeric(I)]
  blank[, m.z := as.numeric(m.z)]
  
  blank[, nominal_mass := floor(m.z + 0.5)]
  
  if (approach == 1) {
    # Use Riedel-based formula (t-statistic with user-defined confidence level)
    res <- blank[, .(
      MDL = qt(confidence_level, df = .N - 1) * sd(I) + mean(I)
    ), by = nominal_mass]
  }
  if(approach ==2){
    # Use Merder 2020 approach with a fixed factor * sd + mean
    res <-   blank[, .(
      MDL = mean(I, na.rm = TRUE) + MDL_level * sd(I, na.rm = TRUE)
    ), by = nominal_mass]
  }
  if(approach ==3){
    #this would be a quantile-based approach where 99% (chosen confidence) of the signal intensities detected in the blank would be excluded
    #for each nominal mass
    res <-  blank[, .(
      MDL = quantile(I, probs = confidence_level, na.rm = TRUE)
    ), by = nominal_mass]
  }
  return(res)
}

# Function to remove outliers in ResPow based on quantile regression
ResPow_outlier <- function(dataset, showplot = F) {
  colnames(dataset)[1] <- "m.z"
  
  nrow_initial <- nrow(dataset)
  
  dataset[, Res. := as.numeric(Res.)]
  
  #dataset <- na.omit(dataset, cols = c("Res.", "m.z"))
  
  # Fit quantile regression model
  d <- rq(log(Res.) ~ log(m.z), data = dataset, method = "fn")
  
  # Density of residuals
  dens <- density(d$residuals)
  
  # Identify threshold e in a single chained operation:
  e <- data.table(x = dens$x[-1], y = diff(dens$y))[
    x > 0
  ][
    which.min(y):.N
  ][
    y > 0, x[1]
  ]
  
  # If no threshold is found, use Inf
  if (is.na(e)) e <- Inf
  
  if(showplot == T){
    plot <- plot_ly (type = "scatter", mode = "markers")
    plot <- plot %>% add_trace(x = dataset$m.z, y = dataset$Res., name = "kept")
    
    removed <-dataset[which(d$residuals > abs(e))]
    
    plot <- plot %>% add_trace(x = removed$m.z, y = removed$Res., name = "removed")
    plot <- plot %>% layout(xaxis = list(title = "m/z"), yaxis = list ( title = "Resolution"))
    print(plot)
  }
  
  
  
  # Return only rows whose residuals are within Â±e
  dataset <-dataset[which(d$residuals <= abs(e))]
  nrow_after <- nrow(dataset)
  message(paste0("Removed ",nrow_initial-nrow_after, " outlier entries"))
  dataset[, Res. := NULL]
  
  return(dataset)
  
}

# Function to process samples and remove peaks below MDL
process_samples_MDL <- function(sample, MDL_master, remove_resolution_outliers = T
) {
  #change integer 64 into numeric for intensity
  colnames(sample)[1] <- "m.z"
  colnames(sample)[2] <- "I"
  sample[, I := as.numeric(I)]
  sample[, m.z := as.numeric(m.z)]
  
  
  
  #Calculate nominal_mz
  sample[, nominal_mass := floor(m.z + 0.5)]
  
  if (any(colnames(sample)=="Res." & remove_resolution_outliers ==T)){
    # 3. Merge, then filter to keep only rows above MDL, 
    #    and pick the necessary columns in a single step.
    setkey(sample, nominal_mass)
    setkey(MDL_master, nominal_mass)
    
    # Filter sample based on MDL
    sample[MDL_master, on = "nominal_mass"][I >= MDL,
                                            .(m.z, I, MDL, Res.)] |>
      ResPow_outlier()
  }else {
    
    setkey(sample, nominal_mass)
    setkey(MDL_master, nominal_mass)
    
    # Filter sample based on MDL
    sample[MDL_master, on = "nominal_mass"][I >= MDL,
                                            .(m.z, I, MDL)]
  }
}

isotope_combinations <- function(formulas_dt, mass_range,
                                 mass_C, mass_H, mass_O, mass_N, mass_S, mass_P) {
  # Construct a grid for all possible isotopes (within the defined maxima).
  isotope_grid <- CJ(
    O_18 = 0:max(formulas_dt$max_O18),
    C_13 = 0:max(formulas_dt$max_C13),
    S_34 = 0:max(formulas_dt$max_S34)
  )
  
  # Only keep relevant combinations:
  #  - Single extra isotope (O_18, S_34, or C_13)
  #    OR a double 13C (C_13 == 2) with no O_18 / S_34
  isotope_grid <- isotope_grid[
    (O_18 + S_34 + C_13 == 1) | (C_13 == 2 & O_18 == 0 & S_34 == 0)
  ]
  
  # Expand the formula set
  expanded_formulas <- formulas_dt[rep(seq_len(.N), each = nrow(isotope_grid))]
  expanded_isotopes <- isotope_grid[rep(seq_len(nrow(isotope_grid)), times = formulas_dt[ , .N])]
  combined_formulas <- cbind(expanded_formulas, expanded_isotopes)
  
  # Only valid if isotopes actually exist in the formula
  combined_formulas <- combined_formulas[
    (C_13 > 0 & O_18 == 0 & S_34 == 0) |
      ((S_34 > 0 & S > 0) | (O_18 > 0 & O > 0))
  ]
  
  # Recompute m/z for these isotopes
  combined_formulas[ ,
                     mz := C * mass_C + H * mass_H + O * mass_O + N * mass_N + S * mass_S + P * mass_P +
                       C_13 * (13.00335540 - mass_C) +
                       O_18 * (17.99915960 - mass_O) +
                       S_34 * (33.96786690 - mass_S)
  ]
  
  # Keep only those within the requested m/z range
  combined_formulas[mz >= mass_range[1] & mz <= mass_range[2]]
}


generate_formulas <- function(C_range = 1:50, H_range = 2:120, O_range = 0:50,
                              N_range = 0:4, S_range = 0:2, P_range = 0:1,
                              mass_range = c(50, 1000), HC = c( 0.2, 3), OC = c(0, 1.2), insert_isotopes = T) {
  
  # Define element masses in one place
  mass_C  <- 12
  mass_H  <- 1.00782503
  mass_O  <- 15.99491463
  mass_N  <- 14.00307400
  mass_S  <- 31.97207117
  mass_P  <- 30.97376203
  
  # Create the grid of C, N, S, P and apply basic filters
  dt <- CJ(C = C_range, N = N_range, S = S_range, P = P_range)[
    C > 0 &
      (N / C) <= 1.3 & (S / C) <= 0.8 & (P / C) <= 0.3 &
      !(N > 1 & (S + P > 0)) &
      !(N != 0 & S != 0 & P != 0) &
      !(S + P > 2) &
      !(N == 1 & (S > 1 | P > 1))
  ]
  
  # Precompute min and max for H and O based on rules
  dt[ , `:=`(
    H_min = pmax(ceiling(HC[1] * C), H_range[1]),
    H_max = pmin(floor(HC[2] * C), max(H_range)),
    O_max = pmin(floor(OC[2] * C), max(O_range))
  )]
  
  # Construct possible (H, O) combinations
  results <- dt[ , {
    if (H_min <= H_max) {
      H_values <- H_min:H_max
      O_values <- seq.int(0, O_max)
      H_O_dt <- CJ(H = H_values, O = O_values)[
        (H / C) >= HC[1] & (H / C) <= HC[2] & (O / C) >= OC[1] & (O / C) <= OC[2]
      ]
    } else {
      H_O_dt <- NULL
    }
    H_O_dt
  }, by = .(C, N, S, P)]
  
  # Compute DBE and valence, then subset
  results[ , `:=`(
    DBE    = 1 + (2 * C - H + N + P) / 2,
    valence = C * 4 + H * 1 + O * 2 + N * 3 + S * 2 + P * 5
  )]
  results <- results[
    DBE >= 0 & DBE %% 1 == 0 &
      valence %% 2 == 0
  ][ , c("DBE", "valence") := NULL]  # drop columns right after filtering
  
  # Compute final m/z
  results[ ,
           mz := C * mass_C + H * mass_H + O * mass_O + N * mass_N + S * mass_S + P * mass_P
  ]
  results <- results[mz >= mass_range[1] & mz <= mass_range[2]]
  
  # Insert isotopes if needed
  if (isTRUE(insert_isotopes)) {
    results[ , `:=`(
      max_O18 = pmin(1, O),
      max_C13 = pmin(2, C),
      max_S34 = pmin(1, S)
    )]
    
    # Reuse the pre-defined function
    results_isotopes <- isotope_combinations(
      formulas_dt = results,
      mass_range  = mass_range,
      mass_C      = mass_C,
      mass_H      = mass_H,
      mass_O      = mass_O,
      mass_N      = mass_N,
      mass_S      = mass_S,
      mass_P      = mass_P
    )
    results <- rbind(results, results_isotopes, use.names = TRUE, fill = TRUE)
    
  } else {
    # If not inserting isotopes, fill with zeros
    results[ , c("O_18", "C_13", "S_34") := 0]
  }
  
  # Final columns, replace NAs, and sort
  results <- results[ , .(
    C, H, O, N, S, P,
    C_13      = ifelse(is.na(C_13), 0, C_13),
    O_18      = ifelse(is.na(O_18), 0, O_18),
    S_34      = ifelse(is.na(S_34), 0, S_34),
    calculated_m.z = round(mz,8)
  )]
  
  setorder(results, calculated_m.z)
  gc()
  return(results)
}


# -- Panel 3 Functions --

mz_recalibration <- function(
    formulas,
    spectrum,
    ppm_tolerance   = 0.5,
    ion             = 1.007825032 + -1 * 0.00054857990907,
    S_MDL_limit     = 2,
    hom_member_min  = 2,
    showplot = F,
    samplename= ""
) {
  SSE_1 <- 0
  SSE_2 <- 0
  plot <- plot_ly(type = "scatter", mode = "text",
                  x = 1, y = 1, text = "Not enough points")%>%
    layout(title = samplename, xaxis = list(title = "m/z"),
           yaxis = list(title = "ppm"))
  
  
  
  data <- copy(spectrum)
  
  data_original <- copy (data)
  
  tryCatch({
    
    # 2) Filter data by I / MDL > S_MDL_limit 
    data <- data[I / MDL > S_MDL_limit]
    
    # 3) Assign formulas 
    out <- formula_assignment_multi_intensity(
      formulas,
      data,
      ppm_tolerance = ppm_tolerance,
      ion           = ion,
      threshold = 500,
      delete_singlets = F,
      delete_MF_without_connection = F
    )[homologues_membership >= hom_member_min]
    
    
    # 5) If the filtered data is still sufficiently large, proceed with outlier filtering + GAM model
    if (nrow(out) > 20) {
      
      # -- Quantile-based filtering in data.table style
      #could also filter along the mz axis?
      Q1   <- quantile(out$ppm, 0.25)
      Q3   <- quantile(out$ppm, 0.75)
      IQRv <- Q3 - Q1
      out  <- out[ppm > (Q1 - 1.5 * IQRv) & ppm < (Q3 + 1.5 * IQRv)]
      
      #could also filter along the mz axis?
      Q1   <- quantile(out$m.z, 0.25)
      Q3   <- quantile(out$m.z, 0.75)
      IQRv <- Q3 - Q1
      out  <- out[m.z > (Q1 - 1.5 * IQRv) & m.z < (Q3 + 1.5 * IQRv)]
      
      
      SSE_1 <- round(sum(out$ppm^2),2)
      
      # -- Fit a GAM model
      gam_model <- gam(ppm ~ s(m.z, bs = "cs", k = 3), data = out)
      #plot(gam_model)
      
      data_original[, predicted_drift_ppm :=
                      predict(gam_model, newdata = .SD),
                    .SDcols = "m.z"]
      data_original[, m.z :=
                      m.z * (1 + predicted_drift_ppm / 1e6)]
      #data_original[, m.z := m.z * (1 + predict(gam_model, newdata = .SD, .SDcols = "m.z") / 1e6)]
      
      
      
    } else {
    }
    
    
    if(showplot & nrow(out) > 20){
      plot1 <- plot_ly() %>%
        
        add_trace(data = out, x = ~m.z, y = ~ppm, type = 'scatter', mode = 'markers',
                  marker = list(color = 'grey', size = 5), name = paste0("SSE before: ",SSE_1)) %>%
        add_trace(data = data_original, x = ~m.z, y = ~predicted_drift_ppm, type = 'scatter', mode = 'lines',
                  line = list(color = 'red', width = 2), name = 'GAM Model') %>%
        layout(title = samplename, xaxis = list(title = "m/z", range=c(min(out$m.z),max(out$m.z))),
               yaxis = list(title = "ppm", range=c(-ppm_tolerance,ppm_tolerance)))
      
      #repeat assignment
      data <- data_original[I / MDL > S_MDL_limit]
      
      # 3) Assign formulas and filter by atomic composition
      out <- formula_assignment_multi_intensity(
        formulas,
        data,
        ppm_tolerance = ppm_tolerance,
        ion           = ion,
        threshold = 500,
        delete_singlets = F,
        delete_MF_without_connection = F
      )[homologues_membership >= hom_member_min]
      
      
      
      
      # -- Quantile-based filtering in data.table style
      Q1   <- quantile(out$ppm, 0.25)
      Q3   <- quantile(out$ppm, 0.75)
      IQRv <- Q3 - Q1
      out  <- out[ppm > (Q1 - 1.5 * IQRv) & ppm < (Q3 + 1.5 * IQRv)]
      
      #could also filter along the mz axis?
      Q1   <- quantile(out$m.z, 0.25)
      Q3   <- quantile(out$m.z, 0.75)
      IQRv <- Q3 - Q1
      out  <- out[m.z > (Q1 - 1.5 * IQRv) & m.z < (Q3 + 1.5 * IQRv)]
      
      
      
      SSE_2 <- round(sum(out$ppm^2),2)
      
      plot2 <- plot_ly() %>%
        
        add_trace(data = out, x = ~m.z, y = ~ppm, type = 'scatter', mode = 'markers',
                  marker = list(color = 'black', size = 5), name = paste0("SSE after: ",SSE_2)) %>%
        
        layout(title = samplename, xaxis = list(title = "m/z", range=c(min(out$m.z),max(out$m.z))), yaxis = list(title = "ppm"))
      
      
      plot <- subplot(plot1, plot2, shareY = T, titleX = T, titleY = T)
      
      
    }
    gc()
    
  }, error = function(e) {
    print(paste0("Error in Sample: ",samplename, ". Original data returned"))
  })
  
  return(list(data =data_original[, .(m.z, I, MDL)],
              plot = plot,
              SSE_1 = SSE_1,
              SSE_2 = SSE_2))
}

# -- Panel 4 Functions --
merge_mz_values <- function(dt, ppm_tolerance) {
  
  
  # Sort by m/z
  
  setorder(dt, m.z)
  
  # Compute difference in ppm between consecutive m/z
  dt[, diff_ppm := (m.z - shift(m.z, type = "lag")) / shift(m.z, type = "lag") * 1e6]
  # Replace the first NA with Inf (equivalent to c(Inf, diff(m.z))/m.z * 1e6)
  dt[is.na(diff_ppm), diff_ppm := Inf]
  
  # Identify groups whose differences exceed ppm_tolerance
  dt[, group := cumsum(diff_ppm > ppm_tolerance)]
  
  # Calculate the weighted mean m/z and other values 
  merged <- dt[, {
    sqrt_I <- sqrt(I)
    sum_sqrt_I <- sum(sqrt_I)
    .(
      merged_m.z = sum(m.z * sqrt_I) / sum_sqrt_I,
      mean_MDL  = MDL[1],            #MDL should be the same accross all samples.                   
      SE        = round(sd(m.z) / (sum(m.z * sqrt_I) / sum_sqrt_I) * 1e6,5)
    )
  }, by = group]
  
  # Update-join  to add columns back
  dt[merged, on = "group", `:=`(
    merged_m.z = i.merged_m.z,
    mean_MDL  = i.mean_MDL,
    SE        = i.SE
  )]
  
  # Remove duplicates by selecting the first row per group and index
  dt2 <- dt[, .SD[1], keyby = .(group, index)]
  
  # Reshape to wide format; each index becomes a column
  dt_wide <- dcast(
    dt2,
    merged_m.z + mean_MDL + SE ~ index,
    value.var = "I",
    fill = NA
  )
  
  # Rename columns for the final output
  setnames(dt_wide, old = c("merged_m.z", "mean_MDL"), new = c("m.z", "MDL"))
  gc()
  return(dt_wide)
}


# -- Panel 5 Functions --
# Compute isotope deviance
isotope_deviance <- function(intensity_parent, intensity_child,
                             number_of_atoms, q, p, number_of_isotopes = 1) {
  expected_intensity_ratio <- dbinom(number_of_isotopes, number_of_atoms, q) /
    dbinom(number_of_atoms, number_of_atoms, p)
  ratio <- intensity_child / intensity_parent
  
  # Weighted mean of ratio, then scaled relative to expected_intensity_ratio
  rdeviance <- ((ratio / expected_intensity_ratio) - 1) * 1000
  return(round(rdeviance))
}



# Identify group connections for a single group
calculate_group_connections <- function(dt_group, diffs) {
  
  group_results <- lapply(names(diffs), function(diff_name){
    diff_vector <- diffs[[diff_name]]
    diff_dt <- dt_group[, .(
      C = C + diff_vector["C"],
      H = H + diff_vector["H"],
      O = O + diff_vector["O"],
      N = N + diff_vector["N"],
      S = S + diff_vector["S"],
      P = P + diff_vector["P"],
      from_index = index
    )]
    
    # Match the diff_dt to dt_group by the new formula
    setkeyv(diff_dt, c("C", "H", "O", "N", "S", "P"))
    setkeyv(dt_group, c("C", "H", "O", "N", "S", "P"))
    
    #the following can throw an error if allow.cartesian is not set to true.
    #need to investigate the reason.
    matched <- dt_group[diff_dt, nomatch = 0L, allow.cartesian = TRUE]
    
    if (nrow(matched) > 0) {
      matched[, .(
        from_index = from_index,
        to_index = index,
        connection_type = diff_name
      )]
      
      
    }
  })
  names(group_results) <- names(diffs)
  
  
  # Combine all connections for this group
  all_group_connections <- rbindlist(group_results, use.names = TRUE, fill = TRUE)
  
  # Tag any formula with no connections
  no_connections <- dt_group[
    !index %in% unique(c(all_group_connections$from_index, all_group_connections$to_index)),
    .(from_index = index, to_index = NA, connection_type = "No Connection")
  ]
  all_group_connections <- rbind(all_group_connections, no_connections, fill = TRUE)
  
  return(all_group_connections)
}

# --- Main Functions ---



# Calculate homologous connections 
calculate_connections <- function(dt, diffs = list(
  CH2 = c(C = 1, H = 2, O = 0, N = 0, S = 0, P = 0),
  H2   = c(C = 0, H = 2, O = 0, N = 0, S = 0, P = 0)
)) {
  
  
  # Group assignment
  dt[, group := fifelse(N > 0 & P > 0, "NP",
                        fifelse(N > 0 & (S > 0 | S_34 > 0), "NS",
                                fifelse((S > 0 | S_34 > 0) & P > 0, "SP",
                                        fifelse(N > 0 & S == 0 & P == 0 & S_34 == 0, "N",
                                                fifelse((S > 0 | S_34 > 0) & N == 0 & P == 0, "S",
                                                        fifelse(P > 0 & S == 0 & N == 0 & S_34 == 0, "P",
                                                                fifelse(O > 0 & P == 0 & S == 0 & N == 0 & S_34 == 0, "CHO",
                                                                        fifelse(O == 0 & P == 0 & S == 0 & N == 0 & S_34 == 0, "CH", "None"))))))))]
  
  # Calculate connections in each group
  
  setorder(dt, C, H, O)
  dt[, index := .I]
  
  
  all_connections <- lapply(unique(dt$group), function(grp){
    dt_group <- dt[group == grp]
    calculate_group_connections(dt_group, diffs)
  }) %>% rbindlist(use.names = T, fill = T)
  
  
  # Graph-based approach to membership
  Ak <- igraph::graph_from_data_frame(all_connections[!is.na(to_index)], directed = FALSE) %>%
    igraph::components()
  membership_dt <- data.table(index = as.integer(names(Ak$membership)),
                              homologues_membership = Ak$membership)
  #sum up network members
  membership_dt[, homologues_membership := .N, by = homologues_membership]
  
  out <- merge(dt, membership_dt, by = "index", all.x = TRUE)
  out[is.na(homologues_membership), homologues_membership := 1]
  
  return(out)
}

# Main formula assignment that calls the above functions
formula_assignment_multi_intensity <- function(
    formulas, dataset, ppm_tolerance = 0.5,
    ion = 1.007825032 + -1 * 0.00054857990907,
    threshold = 1000, return_likeliest = TRUE,
    delete_singlets = FALSE, delete_MF_without_connection = TRUE,
    homologues_network = list(
      CH2 = c(C = 1, H = 2, O = 0, N = 0, S = 0, P = 0),
      H2   = c(C = 0, H = 2, O = 0, N = 0, S = 0, P = 0)
    )
) {
  
  dat <- copy(dataset) #create a clean copy to remove referencing to old dataset
  
  # Get the column names of of the samples
  exclude_cols <- c("m.z", "MDL", "m.z_ion", "C", "H", "O", "N", "S", "P",
                    "C_13", "O_18", "S_34", "calculated_m.z", "absolute_error", "ppm", "MF",
                    "SE","predicted_drift_ppm", "present_in")
  
  int_cols <- setdiff(colnames(dat), exclude_cols)
  
  dat[, present_in := rowSums(!is.na(.SD)), .SDcols = int_cols]
  
  
  # Delete singlets if chosen
  if (delete_singlets) {
    dat <- dat[present_in > 1]
  }
  
  # Adjust m.z by the chosen ion mass
  dat[, m.z_ion := m.z]
  dat[, m.z := m.z + ion]
  
  # Generate tolerance columns
  dat[, `:=`(lower_limit = m.z * (1 - ppm_tolerance / 1e6),
             upper_limit = m.z * (1 + ppm_tolerance / 1e6))]
  
  # Prepare formula data and set keys for overlap
  formulas[, `:=`(start = calculated_m.z, end = calculated_m.z)]
  setkey(formulas, start, end)
  setkey(dat, lower_limit, upper_limit)
  
  all_matches <- data.table()
  # Overlap join
  all_matches <- foverlaps(
    formulas, dat, 
    by.x = c("start", "end"),
    by.y = c("lower_limit", "upper_limit"),
    type = "within", nomatch = 0
  )
  dat[, c("lower_limit", "upper_limit") := NULL]
  #calculate the errors
  
  all_matches[, absolute_error := calculated_m.z - m.z]
  all_matches[, ppm := round(((absolute_error / m.z) * 1e6),3)]
  all_matches[, absolute_error := round(absolute_error,6)]
  
  all_matches[, c("lower_limit", "upper_limit", "start", "end") := NULL]
  
  #construct the formula
  
  all_matches[, MF := paste0(
    ifelse(C > 1, paste0("C", C), ifelse(C == 1, "C", "")),
    ifelse(H > 1, paste0("H", H), ifelse(H == 1, "H", "")),
    ifelse(N > 1, paste0("N", N), ifelse(N == 1, "N", "")),
    ifelse(O > 1, paste0("O", O), ifelse(O == 1, "O", "")),
    ifelse(P > 1, paste0("P", P), ifelse(P == 1, "P", "")),
    ifelse(S > 1, paste0("S", S), ifelse(S == 1, "S", ""))
  )]
  
  #remove isotope formulas where no parent is present
  all_matches <- all_matches[
    !(C_13 > 0 | O_18 > 0 | S_34 > 0) | 
      (duplicated(MF) | duplicated(MF, fromLast = TRUE))
  ]
  
  #plot(all_matches$O/all_matches$C, all_matches$H/ all_matches$C)
  #for the rare case that a merged samplelist contains the same MF with two different masses
  #will select the one with more hits
  setorder(all_matches, MF, -present_in)
  
  #this appears to be neccessary to make the new column numeric; else if will be logical and the deviance function cannot write into this column
  all_matches[, isotope_deviance_C_13_1 := 1]
  all_matches[, isotope_deviance_C_13_2 := 1]
  all_matches[, isotope_deviance_O_18 := 1]
  all_matches[, isotope_deviance_S_34 := 1]
  
  #calculation of isotope deviances
  
  #if multiple samples are present, take the median
  #this can introduce error.
  all_matches[, median_intensity := apply(.SD, 1, median, na.rm = TRUE), .SDcols = int_cols]
  
  all_matches[, isotope_deviance_C_13_1 := {
    parent <- median_intensity[C_13 == 0][1] 
    child <- median_intensity[C_13 == 1][1]# %>% mean()
    if (length(parent) > 0 & length(child > 0)) {
      isotope_deviance(
        parent,
        child,
        number_of_atoms = C[1],
        q = 0.0108,
        p = 1 - 0.0108,
        number_of_isotopes = 1
      )
    } else {NA}
  }, by = MF]
  
  all_matches[, isotope_deviance_C_13_2 := {
    parent <- median_intensity[C_13 == 0] [1]
    child <- median_intensity[C_13 == 2] [1]
    if (length(parent) > 0 & length(child > 0)) {
      isotope_deviance(
        parent,
        child,
        number_of_atoms = C[1],
        q = 0.0108,
        p = 1 - 0.0108,
        number_of_isotopes = 2
      )
    } else {NA}
  }, by = MF]
  
  all_matches[, isotope_deviance_O_18 := {
    parent <- median_intensity[O_18 == 0] [1]
    child <- median_intensity[O_18 == 1] [1]
    if (length(parent) > 0 & length(child > 0)) {
      isotope_deviance(
        parent,
        child,
        number_of_atoms = O[1],
        q = 0.00205,
        p = 1 - 0.00205,
        number_of_isotopes = 1
      )
    } else {NA}
  }, by = MF]
  
  all_matches[, isotope_deviance_S_34 := {
    parent <- median_intensity[S_34 == 0][1] 
    child <- median_intensity[S_34 == 1] [1]
    if (length(parent) > 0 & length(child > 0)) {
      isotope_deviance(
        parent,
        child,
        number_of_atoms = S[1],
        q = 0.0437,
        p = 1 - 0.0437,
        number_of_isotopes = 1
      )
    } else {NA}
  }, by = MF]
  
  all_matches[, median_intensity := NULL]
  
  # Remove rows where C_13 == 2 and isotope_deviance_C_13_1 is NaN, e.g. no C13_1 peak present
  all_matches <- all_matches[!(C_13 == 2 & is.nan(isotope_deviance_C_13_1))]
  
  # Threshold test column
  all_matches[, isotope_below_threshold := (
    (isotope_deviance_C_13_1 < threshold ) |
      (isotope_deviance_C_13_2 < threshold )|
      (isotope_deviance_O_18 < threshold )|
      (isotope_deviance_S_34 < threshold ) 
  )]
  
  # Return only best match per measured m/z if requested
  if (return_likeliest) {
    #remove isotope formulas below threshold
    all_matches <- all_matches[!(
      (isotope_deviance_C_13_1 > threshold & C_13 == 1) |
        (isotope_deviance_C_13_2 > threshold & C_13 == 2)|
        (isotope_deviance_O_18 > threshold & O_18 == 1)|
        (isotope_deviance_S_34 > threshold & S_34 == 1)
    )]
    
    # 2) Homologous series calculation
    all_matches <- calculate_connections(all_matches, diffs = homologues_network)
    
    
    all_matches[, abs_ppm := abs(ppm)]
    all_matches[is.na(isotope_below_threshold), isotope_below_threshold := FALSE]
    
    
    #sort by isotope verified, number of homologues connections and smallest error
    setorder(all_matches, m.z, -isotope_below_threshold,
             -homologues_membership, abs_ppm)
    
    #this is an alternative that can be explored further. Assign CHONS before P.
    # all_matches[, P_greater_than_zero := P > 0]
    # setorder(all_matches, m.z, -isotope_below_threshold,   P_greater_than_zero,
    #          -homologues_membership, abs_ppm)
    # all_matches[, P_greater_than_zero := NULL]  
    #returns only 1 match per unique mz
    all_matches <- all_matches[, .SD[1], by = m.z]
    all_matches[, c("abs_ppm", "homologues_membership") := NULL]
    
    
    # Recompute connections
    all_matches <- calculate_connections(
      all_matches, diffs = homologues_network
    )
    
  } else{
    # 2) Homologous series calculation
    all_matches <- calculate_connections(all_matches, diffs = homologues_network)
    
  }
  
  #add additional columns with indices
  all_matches <- all_matches[, `:=`(
    O.C = O/C, H.C = H/C, N.C = N/C, S.C = S/C, P.C = P/C, 
    AI_mod =  pmax(0, (1 + C - 0.5 * O - S - 0.5 * (H + N + P)) / (C - 0.5 * O - S - N - P)),
    NOSC = ((-(4*C + H - 3*N - 2*O + 5*P - 2*S) / C) + 4),
    DBE    = 1 + (2 * C - H + N + P) / 2
  )][AI_mod <= 1]
  
  all_matches <- all_matches[, `:=`(
    O.C = round(O.C, 3),
    H.C = round(H.C, 3),
    N.C = round(N.C, 3),
    S.C = round(S.C, 3),
    P.C = round(P.C, 3), 
    AI_mod =  round(AI_mod, 3),
    NOSC = round(NOSC, 3),
    m.z = round(m.z, 8),
    m.z_ion = round(m.z_ion, 8)
  )]
  
  # Simple classification
  all_matches[, class := fifelse(
    H.C >= 2 , "Saturated",
    fifelse(
      H.C >= 1.5 & H.C < 2 , "Unsaturated Aliphatic",
      fifelse(
        AI_mod >= 0.67, "Condensed Aromatic",
        fifelse(
          AI_mod < 0.67 & AI_mod > 0.5 , "Aromatic",
          fifelse(
            AI_mod <= 0.5 & H.C < 1.5,
            "Highly unsaturated", "Unassigned"
          )
        )
      )
    )
    
  )]
  
  
  # Possibly delete MF without a homologous connection
  if (delete_MF_without_connection) {
    all_matches <- all_matches[homologues_membership > 1]
  }
  
  #return and custom order of columns
  
  filter_cols <- c(
    "m.z_ion", "m.z", "calculated_m.z", "absolute_error", "ppm", "MF",
    "group", "class", "C", "H", "O", "N", "S", "P", "C_13", "O_18", "S_34",
    "H.C", "O.C", "N.C", "S.C", "P.C", "AI_mod", "NOSC","DBE", "homologues_membership",
    "isotope_deviance_C_13_1", "isotope_deviance_C_13_2",
    "isotope_deviance_O_18", "isotope_deviance_S_34", "isotope_below_threshold","present_in","MDL", int_cols
  )
  all_matches <- all_matches[, ..filter_cols]
  setorder(all_matches, m.z)
  
  
  dat <- NULL
  formulas[, start := NULL]
  formulas[, end := NULL]
  
  
  gc()
  return(all_matches)
}

vk_plot_hist <- function(datasets, trace_names = c(""), title = "", alpha = 0.8, sizes = NULL, colors = NULL, plot_categories =F, plot_hist = T, linewidth = 0.1) {
  library(viridis)
  if (is.null(colors)) {
    colors <- viridis(length(datasets))
  }
  # Ensure the sizes vector has the correct length
  if (is.null(sizes)) {
    sizes <- rep(3, length(datasets))
  }
  
  # Create main Van Krevelen plot
  p <- plot_ly(type = "scatter", mode = "markers")
  
  if (plot_categories==T){
    
    # Define polygons for each class
    Saturated <- data.frame(
      O.C = c(0, 1, 1, 0),
      H.C = c(2, 2, 2.5, 2.5)
    )
    
    unsaturated_aliphatic <- data.frame(
      O.C = c(0, 1, 1, 0),
      H.C = c(1.5, 1.5, 2, 2)
    )
    
    
    condensed_hydrocarbon <- data.frame(
      O.C = c(0, 0, 1, 1),
      H.C = c(0.65, 0, 0, 0.5)
    )
    
    aromatic <- data.frame(
      O.C = c(0, 1, 1, 0),
      H.C = c(0.65, 0.5, 0.8, 0.95)
    )
    
    highly_unsaturated <- data.frame(
      O.C = c(0, 1, 1, 0),
      H.C = c(0.95, 0.8, 1.5, 1.5)
    )
    
    # Create the plot with plotly
    p <- plot_ly() %>%
      add_polygons(data = Saturated, x = ~O.C, y = ~H.C, fillcolor = 'rgba(189,189,189, 0.5)', name = "Saturated", line = list(color = "black", width = 0)) %>%
      add_polygons(data = unsaturated_aliphatic, x = ~O.C, y = ~H.C, fillcolor = 'rgba(159,159,159, 0.5)', name = "Unsaturated aliphatic", line = list(color = "black", width = 0)) %>%
      add_polygons(data = highly_unsaturated, x = ~O.C, y = ~H.C, fillcolor = 'rgba(105,105,105, 0.5)', name = "Highly unsaturated", line = list(color = "black", width = 0))%>%
      
      add_polygons(data = aromatic, x = ~O.C, y = ~H.C, fillcolor = 'rgba(66,66,66, 0.5)', name = "Aromatic", line = list(color = "black", width = 0)) %>%
      add_polygons(data = condensed_hydrocarbon, x = ~O.C, y = ~H.C, fillcolor = 'rgba(45,45,45, 0.5)', name = "Condensed Hydrocarbon", line = list(color = "black", width = 0))
    
  }
  
  for (i in seq_along(datasets)) {
    if(nrow(datasets[[i]]) >0){
      color <- colors[i]
      trace_label <- paste0(trace_names[i], " (n = ", nrow(datasets[[i]]), ")")
      p <- p %>% add_trace(
        x = datasets[[i]]$O.C,
        y = datasets[[i]]$H.C,
        name = trace_label,
        marker = list(
          opacity = alpha,
          color = color,
          size = sizes[[i]],
          line = list(color = "black", width = linewidth)
        )
      )
    }
  }
  
  xaxis <- list(
    title = "O/C",
    showline = TRUE,
    linewidth = 1,
    showgrid = FALSE,
    tickmode = "array",
    ticks = "inside",
    zeroline = FALSE,
    range = c(-0.025, 1.275),
    tickvals = c(0, 0.25, 0.5, 0.75, 1,1.25)
  )
  
  yaxis <- list(
    title = "H/C",
    showline = TRUE,
    linewidth = 1,
    showgrid = FALSE,
    tickmode = "array",
    ticks = "inside",
    zeroline = FALSE,
    range = c(0, 2.5),
    tickvals = c(0, 0.5, 1, 1.5, 2, 2.5)
  )
  
  p <- p %>% layout(
    title = title,
    xaxis = xaxis, 
    yaxis = yaxis,
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.2
    )
  )
  
  # Create histograms and density plots
  
  if (plot_hist==T){
    p.O.C.hist.dens <- plot_ly()
    p.H.C.hist.dens <- plot_ly()
    max_density_oc <- 0
    max_density_hc <- 0
    
    for (i in seq_along(datasets)) {
      if(nrow(datasets[[i]]) >0){
        color <- ifelse(i <= length(colors), colors[i], "black")
        
        p.O.C.hist.dens <- p.O.C.hist.dens %>%
          add_histogram(
            alpha = 0.5,
            x = datasets[[i]]$O.C,
            autobinx = FALSE,
            xbins = list(start = 0, end = 1.25, size = 0.05),
            color = I(color),
            marker = list(line = list(color = "black", width = 0.5)),
            showlegend = FALSE,
            histnorm = "percent"
          )
        
        p.O.C.hist.dens <- p.O.C.hist.dens %>%
          add_lines(
            x = density(datasets[[i]]$O.C)$x[density(datasets[[i]]$O.C)$x > 0],
            y = density(datasets[[i]]$O.C)$y[density(datasets[[i]]$O.C)$x > 0],
            yaxis = "y2",
            line = list(color = color, width = 2),
            showlegend = FALSE
          )
        
        max_density_oc <- max(max_density_oc, max(density(datasets[[i]]$O.C)$y))
        
        p.H.C.hist.dens <- p.H.C.hist.dens %>%
          add_trace(
            alpha = 0.5,
            type = "histogram",
            autobiny = FALSE,
            ybins = list(start = 0, end = 2.5, size = 0.1),
            y = datasets[[i]]$H.C,
            color = I(color),
            marker = list(line = list(color = "black", width = 0.5)),
            showlegend = FALSE,
            histnorm = "percent"
          )
        
        p.H.C.hist.dens <- p.H.C.hist.dens %>%
          add_trace(
            type = "scatter",
            mode = "lines",
            x = density(datasets[[i]]$H.C)$y,
            y = density(datasets[[i]]$H.C)$x,
            xaxis = "x2",
            line = list(color = color, width = 2),
            showlegend = FALSE
          )
        
        max_density_hc <- max(max_density_hc, max(density(datasets[[i]]$H.C)$y))
      }
    }
    
    p.O.C.hist.dens <- p.O.C.hist.dens %>% layout(barmode = "overlay")
    p.O.C.hist.dens <- p.O.C.hist.dens %>%
      layout(
        xaxis = list(
          showline = TRUE,
          linewidth = 1,
          showgrid = FALSE,
          tickmode = "array",
          ticks = "outside",
          zeroline = FALSE,
          range = c(-0.025, 1.275),
          tickvals = c(0, 0.25, 0.5, 0.75, 1.25),
          showticklabels = FALSE
        ),
        yaxis = list(
          showline = FALSE,
          showgrid = FALSE,
          showticklabels = FALSE
        ),
        yaxis2 = list(
          overlaying = "y",
          side = "right",
          range = c(0, max_density_oc * 1.05),
          showline = FALSE,
          showgrid = FALSE,
          showticklabels = FALSE
        )
      )
    
    p.H.C.hist.dens <- p.H.C.hist.dens %>% layout(barmode = "overlay")
    p.H.C.hist.dens <- p.H.C.hist.dens %>%
      layout(
        yaxis = list(
          showline = TRUE,
          linewidth = 1,
          showgrid = FALSE,
          tickmode = "array",
          ticks = "outside",
          zeroline = FALSE,
          range = c(0, 2.5),
          tickvals = c(0, 0.5, 1, 1.5, 2, 2.5),
          showticklabels = FALSE
        ),
        xaxis = list(
          showline = FALSE,
          showgrid = FALSE,
          showticklabels = FALSE
        ),
        xaxis2 = list(
          overlaying = "x4",
          side = "top",
          range = c(0, max_density_hc * 1.05),
          showgrid = FALSE,
          showline = FALSE,
          showticklabels = FALSE
        )
      )
    # Finalize the plot
    p_final <-subplot(
      p.O.C.hist.dens, plotly_empty(),
      p, p.H.C.hist.dens,
      shareX = FALSE, shareY = FALSE, nrows = 2,
      widths = c(0.8, 0.2),
      heights = c(0.2, 0.8),
      margin = 0,
      titleX = TRUE,
      titleY = TRUE
    )
    return(p_final)
  }
  if (plot_hist == F){
    # Finalize the plot
    p
  }
  
}


###############################################################################
#               Panel 1:  Functions & Shiny UI/Server Code                    #
#                    (Instrument Blanks Noise Removal)                    #
###############################################################################

# -- Panel 1 Functions --
# Set maximum file size (adjust as needed)
options(shiny.maxRequestSize = 4096 * 4096 * 4096)



# -- Panel 1 UI --
# -- Panel 1 UI --
panel1_ui <- fluidPage(
  titlePanel("Instrument Blanks Noise Removal"),
  
  sidebarLayout(
    sidebarPanel(
      fileInput("blanks_files", "Select Instrument blank file(s):", 
                multiple = TRUE, accept = c(".csv")),
      fileInput("samples_files", "Select sample files:", 
                multiple = TRUE, accept = c(".csv")),
      
      # Radio buttons to select the approach
      radioButtons(
        inputId = "approach", 
        label = "Select MDL calculation approach:",
        choices = c("Riedel 2014 approach" = 1, "Merder 2020 approach" = 2),
        selected = 1 
      ),
      
      # Conditional panel for inputs relevant only to Riedel 2014 approach
      conditionalPanel(
        condition = "input.approach == '1'",
        numericInput("confidence_level", 
                     "Confidence Level:", 
                     value = 0.998, min = 0, max = 1, step = 0.001)
      ),
      
      # Conditional panel for inputs relevant only to Merder 2020 approach
      conditionalPanel(
        condition = "input.approach == '2'",
        numericInput("MDL_level", 
                     "MDL_level:", 
                     value = 2.5, min = 1, step = 0.1)
      ),
      checkboxInput("remove_resolution_outliers", "Remove resolution outliers", value = TRUE),
      
      actionButton("calculate", "Calculate", class = "btn-lg btn-success"),
      downloadButton("download_MDL", "Download as .rds")  ,
      
    ),
    
    mainPanel(
      h4("Blanks Data Preview (First File)"),
      tableOutput("blanks_preview"),
      h4("Samples Data Preview (First File)"),
      tableOutput("samples_preview"),
      h4("Overview processed samples"),
      tableOutput("overview")
    )
  )
)

# -- Panel 1 Server --
panel1_server <- function(input, output, session) {
  
  blanks_data <- reactive({
    req(input$blanks_files)
    lapply(input$blanks_files$datapath, fread) %>% na.omit()
  })
  
  samples_data <- reactive({
    req(input$samples_files)
    samples <- lapply(input$samples_files$datapath, fread) %>% na.omit()
    names(samples) <- tools::file_path_sans_ext(basename(input$samples_files$name))
    samples
  })
  
  samples_MDL <- eventReactive(input$calculate, {
    notification_id <- showNotification("Calculating...", type = "message", duration = NULL)

    req(blanks_data(), samples_data())
    
    progress1 <- Progress$new(session, min = 0, max = length(blanks_data()))
    on.exit(progress1$close())

    
    # Step 1: Compute MDL_master based on user-selected approach
    MDL_master <- lapply(seq_along(blanks_data()), function(i) {
      progress1$set(value = i, message = "Processing blanks", detail = paste0("Blank ", i, " of ", length(blanks_data())))
      
      
      calculate_noise(blanks_data()[[i]], approach =  as.numeric(input$approach),
                      confidence_level =  input$confidence_level,
                      MDL_level =  input$MDL_level) 
     
    }) %>% rbindlist()

     MDL_master <- MDL_master[order(-MDL), .SD[1], by = nominal_mass]
     MDL_master[, MDL := round(MDL)]
    
     progress1$close()
    
      #Initialize progress bar
     progress2 <- Progress$new(session, min = 0, max = length(samples_data()))
     on.exit(progress2$close())
    
    
    #  Process samples
     processed_samples <- lapply(seq_along(samples_data()), function(i) {
       progress2$set(value = i, message = "Processing samples", detail = paste0("Sample ", i, " of ", length(samples_data())))
       sample <- samples_data()[[i]]
       process_samples_MDL(
         sample      = samples_data()[[i]],
         MDL_master  = MDL_master,
         input$remove_resolution_outliers
       )
    
     })
    
     names(processed_samples) <- names(samples_data())

          # Export processed_samples to the global environment
     assign("samples_MDL", processed_samples, envir = .GlobalEnv)
     gc ()

     output$download_MDL<- downloadHandler(
       filename = function() {
         paste("Noise_cleaned_samples", Sys.Date(), ".rds", sep = "")
       },
       content = function(file) {
         saveRDS(processed_samples, file)
       }
     )
     removeNotification(notification_id)
     
     return(processed_samples)
  })
  

  
   # Render table for blanks_data head
  output$blanks_preview <- renderTable({
    req(blanks_data())
    head(blanks_data()[[1]])
  })
  
  # Render table for samples_data head
  output$samples_preview <- renderTable({
    req(samples_data())
    head(samples_data()[[1]])
  })

  
  output$overview <- renderTable({
    req(samples_MDL())
    
    data.table(
      Sample_Name = names(samples_data()),
      Rows_Before = sapply(samples_data(), nrow),
      Rows_After = sapply(samples_MDL(), nrow),
      Min_mz = sapply(samples_MDL(), function(x) min(x$m.z, na.rm = TRUE)),
      Max_mz = sapply(samples_MDL(), function(x) max(x$m.z, na.rm = TRUE))
    )
  })
}


###############################################################################
#               Panel 2:  Functions & Shiny UI/Server Code                    #
#                      (Molecular Formula Generator)                          #
###############################################################################




# -- Panel 2 UI --
panel2_ui <- fluidPage(
  titlePanel("Molecular Formula Generator"),
  sidebarLayout(
    sidebarPanel(
      actionButton("calc_button", "Calculate Formulas", class = "btn-lg btn-success"),
      sliderInput("C_range", "C Range:", min = 1, max = 100, value = c(1, 50)),
      sliderInput("H_range", "H Range:", min = 1, max = 200, value = c(2, 120)),
      sliderInput("O_range", "O Range:", min = 0, max = 100, value = c(0, 50)),
      sliderInput("N_range", "N Range:", min = 0, max = 10, value = c(0, 4)),
      sliderInput("S_range", "S Range:", min = 0, max = 5, value = c(0, 2)),
      sliderInput("P_range", "P Range:", min = 0, max = 5, value = c(0, 1)),
      sliderInput("mass_range", "Mass Range:", min = 0, max = 2000, value = c(90, 1000)),
      sliderInput("HC", "H/C Range:", min = 0, max = 5, value = c(0.2, 3), step = 0.1),
      sliderInput("OC", "O/C Range:", min = 0, max = 4, value = c(0, 1.2), step = 0.1),
      checkboxInput("insert_isotopes", "Insert Isotopes", value = TRUE),

      downloadButton("download_csv_formulas", "Download CSV")  
    ),
    mainPanel(
      DTOutput("results_table"),
      verbatimTextOutput("calc_message")
    )
  )
)

# -- Panel 2 Server --
panel2_server <- function(input, output, session) {
  
  results <- eventReactive(input$calc_button, {
    notification_id <- showNotification("Calculating...", type = "message", duration = NULL)
    
    out <- generate_formulas(
      C_range = input$C_range[1]:input$C_range[2],
      H_range = input$H_range[1]:input$H_range[2],
      O_range = input$O_range[1]:input$O_range[2],
      N_range = input$N_range[1]:input$N_range[2],
      S_range = input$S_range[1]:input$S_range[2],
      P_range = input$P_range[1]:input$P_range[2],
      mass_range = input$mass_range,
      HC = input$HC,
      OC = input$OC,
      insert_isotopes = input$insert_isotopes
    )
    removeNotification(notification_id)
    # Download handler for CSV file
    output$download_csv_formulas <- downloadHandler(
      filename = function() {
        paste("molecular_formulas", Sys.Date(), ".csv", sep = "")
      },
      content = function(file) {
        fwrite(out, file)
      }
    )
    out
  })
  
  output$results_table <- renderDT({
    head(results())
  })
  
  observeEvent(input$calc_button, {
    assign("molecular_formulas", results(), envir = .GlobalEnv)
    output$calc_message <- renderText({
      "Calculation complete. Results saved to 'formulas' in your R environment."
    })
  })
  
  
}


###############################################################################
#               Panel 3:  Functions & Shiny UI/Server Code                    #
#                      (MZ Recalibration Tool)                                #
###############################################################################

#still performs poorly in areas outside of calibration.



# -- Panel 3 UI --
panel3_ui <- fluidPage(
  titlePanel("MZ Recalibration Tool"),
  sidebarLayout(
    sidebarPanel(
      numericInput("ppm_tolerance", "ppm tolerance:", value = 0.5, min = 0, step = 0.05),
      numericInput("S_MDL_limit", "S/MDL lower limit:", value = 2, min = 0, step = 0.1),
      numericInput("hom_member_min", "Homologue network length min:", value = 2, min = 1, step = 1),
      actionButton("calculate_mz", "Recalibrate", class = "btn-lg btn-success"),
      downloadButton("download_recalibrated", "Download as .rds")  ,
      uiOutput("sample_slider_ui")
    ),
    mainPanel(
      tabsetPanel(
        tabPanel(
          "Plot", 
          fluidRow(
            plotlyOutput("extra_plot"), # Extra plot above the main plot
            plotlyOutput("mz_plot")    # Main m/z plot
          )
        )
      )
    )
  )
)

# -- Panel 3 Server --
panel3_server <- function(input, output, session) {
  
  recal_data <- reactiveVal(NULL)
  
  observeEvent(input$calculate_mz, {
    if (!exists("samples_MDL", envir = .GlobalEnv)) {
      showNotification("Error: 'samples_MDL' not found in global environment.", type = "error")
      return(NULL)
    }
    
    notification_id <- showNotification("Calculating...", type = "message", duration = NULL)
    
    local_samples <- get("samples_MDL", envir = .GlobalEnv)
    #local_formulas <- get("molecular_formulas", envir = .GlobalEnv)
    
    progress <- Progress$new(session, min = 0, max = length(local_samples))
    on.exit(progress$close())
    
    #formulas for calibration: more conservative range
    formulas_calibration <- generate_formulas(C_range = 2:50, H_range = 2:100, O_range = 2:20,
                                              P_range = 0:0, N_range = 0:1, S_range = 0:1,
                                              HC= c(1,2), OC = c(0.2,0.8), mass_range = c(100, 1000), insert_isotopes = T)
    sample_names <- names(local_samples)
    out_list <- lapply(seq_along(local_samples), function(i) {
      progress$set(value = i, message = "Processing samples", detail = paste0("Sample ", i, " of ", length(local_samples)))

      mz_recalibration(formulas_calibration, local_samples[[i]],
                       ppm_tolerance = input$ppm_tolerance,
                       S_MDL_limit = input$S_MDL_limit,
                       hom_member_min = input$hom_member_min,
                       showplot = TRUE, samplename = sample_names[i])

    })
    recal_data(out_list)
    out_data <- lapply(out_list, function(x){x$data})
    names(out_data) <- names(samples_MDL)
    
    #assign("samples_MDL_recal_data", lapply(out_list, `[[`, "data"), envir = .GlobalEnv)
    assign("samples_MDL_recal_data", out_data, envir = .GlobalEnv)
    
    removeNotification(notification_id)
    showNotification("MZ Recalibration complete! 'samples_MDL_recal_data' saved globally.", type = "message")
    
    output$download_recalibrated <- downloadHandler(
      filename = function() {
        paste("Recalibrated_samples", Sys.Date(), ".rds", sep = "")
      },
      content = function(file) {
        saveRDS(out_data, file)
      }
    )
  })
  
  output$sample_slider_ui <- renderUI({
    req(recal_data())
    sliderInput(
      "sample_slider",
      "Select Sample:",
      min = 1,
      max = length(recal_data()),
      value = 1,
      step = 1
    )
  })
  
  current_sample <- reactiveVal(1)
  
  observeEvent(input$sample_slider, {
    req(recal_data())
    current_sample(input$sample_slider)
  })
  
  output$mz_plot <- renderPlotly({
    req(recal_data())
    idx <- current_sample()
    if (idx > 0 && idx <= length(recal_data())) {
      recal_data()[[idx]]$plot
    }
  })
  
  # Generate the extra plot, unaffected by slider
  output$extra_plot <- renderPlotly({
    req(recal_data())
    SSE_1 <- sapply(recal_data(), function(x) x$SSE_1)
    SSE_2 <- sapply(recal_data(), function(x) x$SSE_2)
    x <-seq_along(SSE_1)
    plot_ly(
      x = x,
      y = SSE_1,
      type = "scatter",
      mode = "markers",
      name = "SSE before"
    ) %>%   add_trace(    x = x,
    y = SSE_2,
    type = "scatter",
    mode = "markers",
    name = "SSE after"
  ) %>%  layout(title = "SSE before/after",
                xaxis = list(title = "Sample Index"),
                yaxis = list(title = "SSE"))
  })
}


###############################################################################
#               Panel 4:  Functions & Shiny UI/Server Code                    #
#                      (Merge m/z Values)                                     #
###############################################################################




# -- Panel 4 UI --
panel4_ui <- fluidPage(
  titlePanel("Merge m/z Values"),
  sidebarLayout(
    sidebarPanel(
      numericInput("ppm_tolerance_merge", "PPM Tolerance:", value = 0.5, min = 0, step = 0.1),
      actionButton("calculate_merge", "Merge samples", class = "btn-lg btn-success"),
      downloadButton("download_csv_merged", "Download CSV")  
    ),
    mainPanel(
      verbatimTextOutput("status_merge"),
      DTOutput("results_table_merge")
    )
  )
)

# -- Panel 4 Server --
panel4_server <- function(input, output, session) {
  
  observeEvent(input$calculate_merge, {
    # Ensure samples_MDL_recal_data exists
    if (!exists("samples_MDL_recal_data", envir = .GlobalEnv)) {
      output$status_merge <- renderText("Error: 'samples_MDL_recal_data' is not found in the global environment.")
      return(NULL)
    }
    
    # Perform the calculation
    output$status_merge <- renderText("Calculating...")
    notification_id <- showNotification("Calculating...", type = "message", duration = NULL)
    
    
    tryCatch({
      local_samples <- get("samples_MDL_recal_data", envir = .GlobalEnv)
      combined_dt <- rbindlist(local_samples, fill = TRUE, idcol = "index")
      result_dt <- merge_mz_values(combined_dt, ppm_tolerance = input$ppm_tolerance_merge)
      
      # Assign result to global environment
      assign("merged_samples", result_dt, envir = .GlobalEnv)
      removeNotification(notification_id)
      output$status_merge <- renderText("Calculation complete! Check the global environment for 'merged_samples'. Table below shows the header.")
    }, error = function(e) {
      output$status_merge <- renderText(paste("Error:", e$message))
    })
    output$results_table_merge <- renderDT({
      head(result_dt)
    })
    output$download_csv_merged <- downloadHandler(
      filename = function() {
        paste("Merged_samples", Sys.Date(), ".csv", sep = "")
      },
      content = function(file) {
        fwrite(result_dt, file)
      }
    )
    
  })
}

###############################################################################
#               Panel 5:  Functions & Shiny UI/Server Code                    #
#              (Formula Assignment and Isotope Calculation)                   #
###############################################################################




# -- Panel 5 UI --
panel5_ui <- fluidPage(
  titlePanel("Formula Assignment and Isotope Calculation"),
  sidebarLayout(
    sidebarPanel(
      numericInput("ppm_tolerance_panel5", "ppm tolerance:", value = 0.3, min = 0, step = 0.1),
      numericInput("threshold_panel5", "Isotope deviance threshold:", value = 1000, min = 0, step = 1),
      checkboxInput("return_likeliest_panel5", "Return Likeliest", value = TRUE),
      checkboxInput("delete_singlets", "Delete Singlets", value = TRUE),
      checkboxInput("delete_MF_without_connection", "Delete MF without Connection", value = TRUE),
      checkboxGroupInput("homologues_network_panel5", "Select Homologues Network:", 
                         choices = list(
                           "CH2"  = "CH2",
                           "CH2O" = "CH2O",
                           "C2HO" = "C2HO",
                           "CO2"  = "CO2",
                           "H2O"  = "H2O",
                           "H2"    = "H2",
                           "O"    = "O",
                           "NH3"  = "NH3"
                         ),
                         selected = c("CH2",  "O")),
      actionButton("calculate_panel5", "Assign Formulas", class = "btn-lg btn-success"),
      downloadButton("download_csv_crosstab", "Download CSV") ,
      textOutput("status_panel5")
    ),
    mainPanel(
      plotlyOutput("VK_plot"),
      DTOutput("results_table_panel_5")
    )
  )
)

# -- Panel 5 Server --
panel5_server <- function(input, output, session) {
  
  crosstab <- reactiveVal(NULL)
  
  observeEvent(input$calculate_panel5, {
    output$status_panel5 <- renderText("Calculating...")
    
    # Ensure we have 'formulas' and 'merged_samples' in global environment
    if (!exists("molecular_formulas", envir = .GlobalEnv)) {
      output$status_panel5 <- renderText("Error: 'formulas' is not found in the global environment.")
      return(NULL)
    }
    if (!exists("merged_samples", envir = .GlobalEnv)) {
      output$status_panel5 <- renderText("Error: 'merged_samples' is not found in the global environment.")
      return(NULL)
    }
    
    local_formulas <- get("molecular_formulas", envir = .GlobalEnv)
    local_water_dt <- get("merged_samples", envir = .GlobalEnv)
    
    tryCatch({
      selected_homologues <- list()
      if ("CH2"  %in% input$homologues_network_panel5) selected_homologues$CH2  <- c(C = 1, H = 2, O = 0, N = 0, S = 0, P = 0)
      if ("CH2O" %in% input$homologues_network_panel5) selected_homologues$CH2O <- c(C = 1, H = 2, O = 1, N = 0, S = 0, P = 0)
      if ("C2HO" %in% input$homologues_network_panel5) selected_homologues$C2HO <- c(C = 2, H = 1, O = 1, N = 0, S = 0, P = 0)
      if ("CO2"  %in% input$homologues_network_panel5) selected_homologues$CO2  <- c(C = 1, H = 0, O = 2, N = 0, S = 0, P = 0)
      if ("H2O"  %in% input$homologues_network_panel5) selected_homologues$H2O  <- c(C = 0, H = 2, O = 1, N = 0, S = 0, P = 0)
      if ("H2"    %in% input$homologues_network_panel5) selected_homologues$H2    <- c(C = 0, H = 2, O = 0, N = 0, S = 0, P = 0)
      if ("O"    %in% input$homologues_network_panel5) selected_homologues$O    <- c(C = 0, H = 0, O = 1, N = 0, S = 0, P = 0)
      if ("NH3"  %in% input$homologues_network_panel5) selected_homologues$NH3  <- c(C = 0, H = 3, O = 0, N = 1, S = 0, P = 0)
      
      notification_id <- showNotification("Calculating...", type = "message", duration = NULL)
      
      result <- formula_assignment_multi_intensity(
        formulas          = local_formulas,
        dataset           = local_water_dt,
        ppm_tolerance     = input$ppm_tolerance_panel5,
        threshold         = input$threshold_panel5,
        return_likeliest  = input$return_likeliest_panel5,
        homologues_network= selected_homologues,
        delete_singlets   = input$delete_singlets,
        delete_MF_without_connection = input$delete_MF_without_connection
      )
      
      crosstab(result)
      
      assign("crosstab", result, envir = .GlobalEnv)
      output$status_panel5 <- renderText("Calculation complete. Results saved to 'crosstab' in your R environment.")
      removeNotification(notification_id)
      
      output$download_csv_crosstab <- downloadHandler(
        filename = function() {
          paste("crosstab", Sys.Date(), ".csv", sep = "")
        },
        content = function(file) {
          fwrite(result, file)
        }
      )
      
    }, error = function(e) {
      output$status_panel5 <- renderText(paste("Error:", e$message))
    })
  })
  
  output$results_table_panel_5 <- renderDT({
    crosstab()
  })
  
  output$VK_plot <- renderPlotly({
    req(crosstab())
    vk_plot_hist(list(crosstab()))
  })
  
  
}


###############################################################################
#                             COMBINED UI & SERVER                             #
###############################################################################

# Combine all panel UIs into one "navbarPage".
# Then define one server that calls each panelâs server function within its own scope.

ui <- navbarPage(
  title = "Formula Assigner",
  
  tabPanel(
    "MDL",
    panel1_ui
  ),
  
  tabPanel(
    "Formula Template",
    panel2_ui
  ),
  
  tabPanel(
    "Recalibration",
    panel3_ui
  ),
  
  tabPanel(
    "Sample Merging",
    panel4_ui
  ),
  
  tabPanel(
    "Formula Assignment",
    panel5_ui
  )
)

# A single server function that calls each panel's server logic
server <- function(input, output, session) {
  callModule(module = panel1_server, id = NULL)
  callModule(module = panel2_server, id = NULL)
  callModule(module = panel3_server, id = NULL)
  callModule(module = panel4_server, id = NULL)
  callModule(module = panel5_server, id = NULL)
  
  session$onSessionEnded(function() {
    stopApp()
  })
}

# Launch the unified Shiny app
shinyApp(ui, server)


